package edu.robertob.p1compi2.analysis;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.List;
import java.util.HashMap;

import edu.robertob.p1compi2.engine.structs.*;
import edu.robertob.p1compi2.engine.base.*;
import edu.robertob.p1compi2.engine.statements.*;
import edu.robertob.p1compi2.engine.expressions.*;


parser code
{:
    PLexer s;
    PParser(PLexer s){this.s = s;}
    private LinkedList<PError> errorList = new LinkedList<>();
    public LinkedList<PError> getSyntaxErrorList(){
        return errorList;
    }
//
    public void syntax_error(Symbol s){
        errorList.add(new PError("✍ Sintaxis", "No se esperaba el componente: "+s.value, s.left, s.right));
//          System.out.println("Syntax error at line: "+s.left+" column: "+s.right + " at symbol: "+s.value);
//          System.out.println(expected_token_ids());
    }
//
    public void unrecovered_syntax_error (Symbol s){
        errorList.add(new PError("✍ ERROR FATAL - Deteniendo...", "No se esperaba el componente: "+s.value, s.left, s.right));
//        System.out.println("Unrecovered syntax error at line: "+s.left+" column: "+s.right + " at symbol: "+s.value);
//        System.out.println(expected_token_ids());
    }

//    public void report_error(String message, Object info){
//        errorList.add(new PError("Sintaxis", message);
//        System.out.println("info: "+info + " message: "+message);
//    }

:}

action code
{::}

// Reserverd words
terminal RW_AND, RW_ARRAY, RW_BEGIN, RW_CASE, RW_CONST, RW_DIV, RW_DO, RW_DOWNTO, RW_ELSE, RW_END, RW_FILE, RW_FOR, RW_FUNCTION, RW_GOTO, RW_IF, RW_IN, RW_LABEL, RW_MOD, RW_NIL, RW_NOT, RW_OF, RW_OR, RW_PACKED, RW_PROCEDURE, RW_PROGRAM, RW_RECORD, RW_REPEAT, RW_SET, RW_THEN, RW_TO, RW_TYPE, RW_UNTIL, RW_VAR, RW_WHILE, RW_WITH, RW_TRUE, RW_FALSE, RW_INTEGER, RW_REAL, RW_CHAR, RW_STRING, RW_BOOLEAN, RW_AND_THEN, RW_OR_ELSE, RW_BREAK, RW_CONTINUE, RW_WRITELN, RW_READLN;

terminal UNIT_MINUS;
terminal String STRING, ID, INTEGER, DECIMAL, CHAR;
terminal PLUS, MINUS, EQUALS, OPENBRACE, CLOSEBRACE, ASTERISK, SLASH, MODULO, DOUBLEASTERISK, NEGATION, COLON;
terminal DOUBLEEQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, NOT_EQUALS, LTGT;
terminal OPENPAR, CLOSEPAR;
terminal OR, AND, NOT;
terminal COMMA, SEMICOLON, OPENBRACKET, CLOSEBRACKET, DOT, UNDERSCORE, ARROW;

nonterminal Statement START, PROGRAM;
nonterminal Program.ProgramHeader PROGRAM_HEADER;
nonterminal Statement PROGRAM_BODY, PROGRAM_BODY_STATEMENT;

//nonterminal Statement DECLARATIONS_BLOCK;
nonterminal Object[] DECLARATIONS_BLOCK;
nonterminal LinkedList<TypeDeclaration> TYPE_DECLARATION_BLOCK;
nonterminal LinkedList<TypeDeclaration> TYPE_DECLARATION_LIST;

nonterminal Statement TYPE_DECLARATION;
nonterminal LinkedList<String> IDENTIFIER_LIST;

nonterminal TypeDeclaration.ArrayTypeDeclarationHelper ARRAY_TYPE;
nonterminal Integer RANGE_INT;
nonterminal Object[] RANGE_DEF;
nonterminal Statement RECORD_DECLARATION, FIELD_LIST, FIELD_DECLARATION, RECORD_USE;


nonterminal LinkedList<Statement> CONSTANT_DECLARATION_BLOCK, CONSTANT_DECLARATION_LIST;
nonterminal Statement CONSTANT_VALUE, CONSTANT_DECLARATION;

nonterminal LinkedList<Statement> VARIABLE_DECLARATION_BLOCK, VARIABLE_DECLARATION_LIST;
nonterminal Statement VARIABLE_DECLARATION;
nonterminal Integer TYPE;


nonterminal Statement EXPRESSION;

nonterminal Statement STATEMENTS, STATEMENT;
nonterminal Statement SYMBOL_ASSIGNATION;

nonterminal Statement IF_STATEMENT, ELSE_IF_BLOCKS, ELSE_IF_BLOCK;

nonterminal Statement CASE_STATEMENT, CASE_ELEMENT_LIST, CASE_ELEMENT, CASE_VALUE_LIST, CASE_ELSE, CASE_VALUE;

nonterminal Statement WHILE_STATEMENT, REPEAT_STATEMENT, FOR_STATEMENT;

nonterminal Statement FUNCTION_DECLARATION_BLOCK, FUNCTION_DECLARATION_START, PARAMETERS_DECLARATION, PARAMETER_DECLARATION;
nonterminal Statement PROCEDURE_DECLARATION_BLOCK, PROCEDURE_DECLARATION_START;
nonterminal Statement WRITELN_CALL, READLN_CALL;
nonterminal Statement PROCEDURE_FUNCTION_DECLARATIONS, PROCEDURE_FUNCTION_DECLARATION;

nonterminal Statement CALL_TO_METHOD, CALL_ARGUMENTS, ARGUMENT;

// Precedence: not > and > or > or else, and then
precedence left RW_OR_ELSE, RW_AND_THEN;
precedence left RW_OR;
precedence left RW_AND;
precedence left RW_NOT;
precedence left EQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, LTGT;
precedence left PLUS, MINUS;
precedence left ASTERISK, RW_DIV, RW_MOD;
precedence left RW_ELSE;
precedence right UNIT_MINUS;

start with PROGRAM;

START ::= PROGRAM:a {: RESULT = a; :}
;

PROGRAM ::= PROGRAM_HEADER PROCEDURE_FUNCTION_DECLARATIONS RW_BEGIN PROGRAM_BODY RW_END
;

PROCEDURE_FUNCTION_DECLARATIONS ::= PROCEDURE_FUNCTION_DECLARATIONS PROCEDURE_FUNCTION_DECLARATION
                                  | PROCEDURE_FUNCTION_DECLARATION
                                  ;

PROCEDURE_FUNCTION_DECLARATION ::= FUNCTION_DECLARATION_BLOCK
                            | PROCEDURE_DECLARATION_BLOCK
                            ;

PROGRAM_HEADER ::=
    RW_PROGRAM ID:a DECLARATIONS_BLOCK:b {:
    RESULT = new Program.ProgramHeader(aleft, aright, a);
    var typesList = (LinkedList<TypeDeclaration>)b[0];
    var constsList = (LinkedList<Statement>)b[1];
    var varsList = (LinkedList<Statement>)b[2];
    if (typesList == null) typesList = new LinkedList<>();
    if (constsList == null) constsList = new LinkedList<>();
    if (varsList == null) varsList = new LinkedList<>();

    RESULT.getStatements().addAll(typesList);
    RESULT.getStatements().addAll(constsList);
    RESULT.getStatements().addAll(varsList);
    System.out.println("Program header: "+RESULT.getStatements().size());
    :}
;

DECLARATIONS_BLOCK ::=
                TYPE_DECLARATION_BLOCK:typesList CONSTANT_DECLARATION_BLOCK:constsList VARIABLE_DECLARATION_BLOCK:varsList
                {: RESULT = new Object[]{typesList, constsList, varsList}; System.out.println("Declarations block: "+typesList.size()+" "+constsList.size()+" "+varsList.size()); :}
                ;

/* this production is for the main program block
because we need to handle special things like semicolons inside if blocks, etc.
*/
PROGRAM_BODY ::= PROGRAM_BODY PROGRAM_BODY_STATEMENT
               | PROGRAM_BODY_STATEMENT
              ;

PROGRAM_BODY_STATEMENT ::= SYMBOL_ASSIGNATION SEMICOLON
                            | IF_STATEMENT
                            | CASE_STATEMENT
                            | WHILE_STATEMENT
                            | REPEAT_STATEMENT
                            | FOR_STATEMENT
                            | RW_BREAK SEMICOLON
                            | RW_CONTINUE SEMICOLON
//                            | FUNCTION_DECLARATION_BLOCK
//                            | PROCEDURE_DECLARATION_BLOCK
                            | CALL_TO_METHOD SEMICOLON
                            | WRITELN_CALL SEMICOLON
                            | READLN_CALL SEMICOLON
                            ;

STATEMENTS ::= STATEMENTS SEMICOLON STATEMENT
             | STATEMENT
             | /* empty */
             ;

STATEMENT ::= SYMBOL_ASSIGNATION
            | IF_STATEMENT
            | CASE_STATEMENT
            | WHILE_STATEMENT
            | REPEAT_STATEMENT
            | FOR_STATEMENT
            | RW_BREAK
            | RW_CONTINUE
            | CALL_TO_METHOD
            | WRITELN_CALL
            | READLN_CALL
            ;

/*
Type definitions
*/

TYPE_DECLARATION_BLOCK ::= RW_TYPE TYPE_DECLARATION_LIST:a {: RESULT = a; :}
                          | /* empty */ {: RESULT = new LinkedList<>(); :}
;


TYPE_DECLARATION_LIST ::= TYPE_DECLARATION:a {: RESULT = new LinkedList<>(); RESULT.add((TypeDeclaration)a); :}
                        | TYPE_DECLARATION:a SEMICOLON {: RESULT = new LinkedList<>(); RESULT.add((TypeDeclaration)a); :}
                        | TYPE_DECLARATION:a SEMICOLON TYPE_DECLARATION_LIST:b {: RESULT = b; b.add((TypeDeclaration)a); :}
                        ;

//TYPE_DECLARATION_LIST ::= TYPE_DECLARATION_LIST SEMICOLON TYPE_DECLARATION
//                        | TYPE_DECLARATION
//                        | /* empty */
//                        ;

TYPE_DECLARATION ::= IDENTIFIER_LIST:a EQUALS TYPE:b {: RESULT = new TypeDeclaration(aleft, aright, a, b, false, false, false, 1, 0, 0); :}
                   | IDENTIFIER_LIST:a EQUALS ARRAY_TYPE:b {: RESULT = new TypeDeclaration(aleft, aright, a, b.getParentTypeId(), true, false, false, ((int)b.getRangeDefinition()[1] - (int)b.getRangeDefinition()[0])+1, (int)b.getRangeDefinition()[0], (int)b.getRangeDefinition()[1]); :}
                   | IDENTIFIER_LIST:a EQUALS RANGE_DEF:b {: RESULT = new TypeDeclaration(aleft, aright, a, TypesTable.DefaultTypes.INTEGER.id, false, true, false, 1, (int)b[0], (int)b[1]); :}
//                   | IDENTIFIER_LIST EQUALS RW_RECORD ID
                   | RECORD_DECLARATION
                   ;


IDENTIFIER_LIST ::= IDENTIFIER_LIST:a COMMA ID:b {: RESULT = a; a.add(b); :}
                  | ID:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                  ;

TYPE ::= RW_INTEGER:a {: RESULT = TypesTable.DefaultTypes.INTEGER.id; :}
         | RW_REAL:a {: RESULT = TypesTable.DefaultTypes.REAL.id; :}
         | RW_CHAR:a {: RESULT = TypesTable.DefaultTypes.CHARACTER.id; :}
         | RW_STRING:a {: RESULT = TypesTable.DefaultTypes.STRING.id; :}
         | RW_BOOLEAN:a {: RESULT = TypesTable.DefaultTypes.BOOLEAN.id; :}
         ;

/*
Range and array types
*/
RANGE_INT ::= INTEGER:a {: RESULT = Integer.parseInt(a); :}
            | MINUS INTEGER:a {: RESULT = Integer.parseInt(a) * -1; :}
            ;

RANGE_DEF ::= RANGE_INT:min DOT DOT RANGE_INT:max {: RESULT = new Object[]{min, max}; :}
            | CHAR:min DOT DOT CHAR:max {: RESULT = new Object[]{(int)min.charAt(0), (int)max.charAt(0)}; :}
             ;

ARRAY_TYPE ::=
    RW_ARRAY OPENBRACKET RANGE_DEF:a CLOSEBRACKET RW_OF TYPE:b {: RESULT = new TypeDeclaration.ArrayTypeDeclarationHelper(a, b); :}
  | RW_PACKED RW_ARRAY OPENBRACKET RANGE_DEF:a CLOSEBRACKET RW_OF TYPE:b {: RESULT = new TypeDeclaration.ArrayTypeDeclarationHelper(a, b); :}
;

/*
Record type definitions
*/

RECORD_DECLARATION ::= IDENTIFIER_LIST EQUALS RECORD_USE
                   ;

RECORD_USE ::= RW_RECORD FIELD_LIST RW_END
                    ;

FIELD_LIST ::= FIELD_DECLARATION
            | FIELD_DECLARATION SEMICOLON
            | FIELD_DECLARATION SEMICOLON FIELD_LIST
            ;


FIELD_DECLARATION ::= IDENTIFIER_LIST COLON TYPE
                    | IDENTIFIER_LIST COLON ARRAY_TYPE
                    | IDENTIFIER_LIST COLON RANGE_DEF
                    | IDENTIFIER_LIST COLON RW_RECORD ID
                    ;

/*
const and var definitions
*/

/*
Constant Declarations
*/
CONSTANT_DECLARATION_BLOCK ::= RW_CONST CONSTANT_DECLARATION_LIST:a {: RESULT = a; :}
                             | /* empty */ {: RESULT = new LinkedList<>(); :}
;

CONSTANT_DECLARATION_LIST ::= CONSTANT_DECLARATION:a SEMICOLON CONSTANT_DECLARATION_LIST:b {: RESULT = b; b.add(a); :}
                            | CONSTANT_DECLARATION:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                            | /* empty */ {: RESULT = new LinkedList<>(); :}
;

// params: int typeId, int line, int column, String id, Statement value
CONSTANT_DECLARATION ::= ID:a EQUALS CONSTANT_VALUE:b {: RESULT = new ConstantDeclaration(-1, aleft, aright, a, b); :}
;

CONSTANT_VALUE ::= INTEGER:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.INTEGER.id, Integer.parseInt(a)); :}
                 | DECIMAL:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.REAL.id, Double.parseDouble(a)); :}
                 | CHAR:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.CHARACTER.id, (int)a.charAt(0)); :}
                 | STRING:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.STRING.id, a); :}
                 | RW_TRUE:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.BOOLEAN.id, true); :}
                 | RW_FALSE:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.BOOLEAN.id, false); :}
                 ;

/*
Variable Declarations
*/

VARIABLE_DECLARATION_BLOCK ::= RW_VAR VARIABLE_DECLARATION_LIST:a {: RESULT = a; :}
                          | /* empty */ {: RESULT = new LinkedList<>(); :}
;


VARIABLE_DECLARATION_LIST ::= VARIABLE_DECLARATION:a SEMICOLON VARIABLE_DECLARATION_LIST:b {: RESULT = b; b.add(a); :}
                         | VARIABLE_DECLARATION:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                         | /* empty */ {: RESULT = new LinkedList<>(); :}
;
// params: int typeId, int line, int column, LinkedList<String> ids, Statement value, boolean isArray, boolean isRange, boolean isRecord, Object minVal, Object maxVal, String parentTypeName, int parentTypeId
VARIABLE_DECLARATION ::= IDENTIFIER_LIST:a COLON TYPE:b {: RESULT = new VariableDeclaration(-1, aleft, aright, a, null, false, false, false, null, null, null, b); :}
                    | IDENTIFIER_LIST:a COLON ID:b {: RESULT = new VariableDeclaration(-1, aleft, aright, a, null, false, false, true, null, null, b, -1); :}
                    | IDENTIFIER_LIST:a COLON ARRAY_TYPE:b {: RESULT = new VariableDeclaration(-1, aleft, aright, a, null, true, false, false, b.getRangeDefinition()[0], b.getRangeDefinition()[1], null, b.getParentTypeId()); :}
                    | IDENTIFIER_LIST:a COLON RECORD_USE:b {::}
                    | IDENTIFIER_LIST:a COLON RANGE_DEF:b {: RESULT = new VariableDeclaration(-1, aleft, aright, a, null, false, true, false, b[0], b[1], null, TypesTable.DefaultTypes.INTEGER.id); :}
;

/*
assignations
*/

SYMBOL_ASSIGNATION ::= ID COLON EQUALS EXPRESSION
                    | ID OPENBRACKET EXPRESSION CLOSEBRACKET COLON EQUALS EXPRESSION
;

/*
if, else if, else statements
*/

IF_STATEMENT ::=
//<editor-fold desc="if else">

  // if (exp) then statement;
  RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT SEMICOLON

  // if (exp) then begin {statements;} end;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END SEMICOLON

  // if (exp) then statement else statement;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT RW_ELSE STATEMENT SEMICOLON

  // if (exp) then begin {statements;} end else statement;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END RW_ELSE STATEMENT SEMICOLON

  // if (exp) then begin {statements;} end else begin {statements;} end;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END RW_ELSE RW_BEGIN PROGRAM_BODY RW_END SEMICOLON

  // if (exp) then statement else begin {statements;} end;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT RW_ELSE RW_BEGIN PROGRAM_BODY RW_END SEMICOLON

  // with else if
  // if (exp) then statement else if (exp) ...;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT ELSE_IF_BLOCKS SEMICOLON

  // if (exp) then begin {statements;} end else if (exp) ...;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END RW_ELSE ELSE_IF_BLOCKS SEMICOLON

  // if (exp) then statement else if (exp) ... else statement;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT ELSE_IF_BLOCKS RW_ELSE STATEMENT SEMICOLON

  // if (exp) then begin {statements;} else if ... end else statement;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END ELSE_IF_BLOCKS RW_ELSE STATEMENT SEMICOLON

  // if (exp) then begin {statements;} end else if ... else begin {statements;} end;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END ELSE_IF_BLOCKS RW_ELSE RW_BEGIN PROGRAM_BODY RW_END SEMICOLON

  // if (exp) then statement else if ... else begin {statements;} end;
  | RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT ELSE_IF_BLOCKS RW_ELSE RW_BEGIN PROGRAM_BODY RW_END SEMICOLON

//</editor-fold>
;

ELSE_IF_BLOCKS ::= ELSE_IF_BLOCKS ELSE_IF_BLOCK
                 | ELSE_IF_BLOCK
//                 | /* empty */
                 ;

ELSE_IF_BLOCK ::= RW_ELSE RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN STATEMENT {: System.out.println("ELSE IF BLOCK"); :} %prec RW_ELSE
                | RW_ELSE RW_IF OPENPAR EXPRESSION CLOSEPAR RW_THEN RW_BEGIN PROGRAM_BODY RW_END  {: System.out.println("ELSE IF BLOCK"); :}%prec RW_ELSE
                ;

/*
case statements
*/

CASE_STATEMENT ::=
    // case exp of
    RW_CASE OPENPAR EXPRESSION CLOSEPAR RW_OF CASE_ELEMENT_LIST CASE_ELSE RW_END SEMICOLON
    | RW_CASE OPENPAR EXPRESSION CLOSEPAR RW_OF CASE_ELEMENT_LIST RW_END SEMICOLON
    ;

/* Define the list of case elements */
CASE_ELEMENT_LIST ::= CASE_ELEMENT_LIST CASE_ELEMENT
                    | CASE_ELEMENT
                    ;

/* Define an individual case element */
CASE_ELEMENT ::= CASE_VALUE_LIST COLON STATEMENT SEMICOLON
               | CASE_VALUE_LIST COLON RW_BEGIN PROGRAM_BODY RW_END
               ;

/* Define the possible values for each case */
CASE_VALUE_LIST ::= CASE_VALUE_LIST COMMA EXPRESSION
                  | EXPRESSION
                  ;

/* Define the optional else part of the case statement more explicitly */
CASE_ELSE ::= RW_ELSE STATEMENT SEMICOLON
            | RW_ELSE RW_BEGIN PROGRAM_BODY RW_END
            ;

/*
while loop
*/

WHILE_STATEMENT ::= RW_WHILE OPENPAR EXPRESSION CLOSEPAR RW_DO STATEMENT SEMICOLON
                  | RW_WHILE OPENPAR EXPRESSION CLOSEPAR RW_DO RW_BEGIN PROGRAM_BODY RW_END SEMICOLON
                  ;

/*
* repeat until loop
*/

REPEAT_STATEMENT ::= RW_REPEAT PROGRAM_BODY RW_UNTIL EXPRESSION SEMICOLON
                    ;

/*
* for do loop
*/

FOR_STATEMENT ::= RW_FOR ID COLON EQUALS EXPRESSION RW_TO EXPRESSION RW_DO STATEMENT SEMICOLON
                | RW_FOR ID COLON EQUALS EXPRESSION RW_DOWNTO EXPRESSION RW_DO STATEMENT SEMICOLON
                | RW_FOR ID COLON EQUALS EXPRESSION RW_TO EXPRESSION RW_DO RW_BEGIN PROGRAM_BODY RW_END SEMICOLON
                | RW_FOR ID COLON EQUALS EXPRESSION RW_DOWNTO EXPRESSION RW_DO RW_BEGIN PROGRAM_BODY RW_END SEMICOLON
                ;

/*
* function and procedure declarations
*/

FUNCTION_DECLARATION_BLOCK ::= FUNCTION_DECLARATION_START DECLARATIONS_BLOCK RW_BEGIN PROGRAM_BODY RW_END SEMICOLON
                             ;

FUNCTION_DECLARATION_START ::= RW_FUNCTION ID OPENPAR PARAMETERS_DECLARATION CLOSEPAR COLON TYPE SEMICOLON
;

PROCEDURE_DECLARATION_BLOCK ::= PROCEDURE_DECLARATION_START DECLARATIONS_BLOCK RW_BEGIN PROGRAM_BODY RW_END SEMICOLON
                             ;

PROCEDURE_DECLARATION_START ::= RW_PROCEDURE ID OPENPAR PARAMETERS_DECLARATION CLOSEPAR SEMICOLON
;

/*
parameters, examples:

argument0: type1; argument1, argument2: type2; ...
*/
PARAMETERS_DECLARATION ::= PARAMETERS_DECLARATION SEMICOLON PARAMETER_DECLARATION
                         | PARAMETER_DECLARATION
                         ;

PARAMETER_DECLARATION ::=
                        // By value
                        IDENTIFIER_LIST COLON TYPE
                        | IDENTIFIER_LIST COLON ARRAY_TYPE
                        | IDENTIFIER_LIST COLON RANGE_DEF
                        | IDENTIFIER_LIST COLON /*RW_RECORD*/ ID

                        // By reference
                        | RW_VAR IDENTIFIER_LIST COLON TYPE
                        | RW_VAR IDENTIFIER_LIST COLON ARRAY_TYPE
                        | RW_VAR IDENTIFIER_LIST COLON RANGE_DEF
                        | RW_VAR IDENTIFIER_LIST COLON /*RW_RECORD*/ ID
                        ;
/*
* functions/procedures calls
*/

CALL_TO_METHOD ::= ID OPENPAR CALL_ARGUMENTS CLOSEPAR
                 ;

CALL_ARGUMENTS ::= CALL_ARGUMENTS COMMA EXPRESSION
                | EXPRESSION
                | /* empty */
                ;

ARGUMENT ::= EXPRESSION
              ;

/*
reserved functions (writeln and readln)
*/
WRITELN_CALL ::= RW_WRITELN OPENPAR CALL_ARGUMENTS CLOSEPAR
               ;

READLN_CALL ::= RW_READLN OPENPAR CALL_ARGUMENTS CLOSEPAR
                ;

/*
expressions handling
*/

EXPRESSION ::= ID
             | INTEGER:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.INTEGER.id, Integer.parseInt(a)); :}
             | DECIMAL:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.REAL.id, Double.parseDouble(a)); :}
             | CHAR:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.CHARACTER.id, (int)a.charAt(0)); :}
             | STRING:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.STRING.id, a); :}
             | RW_TRUE:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.BOOLEAN.id, true); :}
             | RW_FALSE:a {: RESULT = new Primitive(aleft, aright, TypesTable.DefaultTypes.BOOLEAN.id, false); :}
             | EXPRESSION PLUS EXPRESSION
             | EXPRESSION MINUS EXPRESSION
             | EXPRESSION ASTERISK EXPRESSION
             | EXPRESSION RW_DIV EXPRESSION
             | EXPRESSION RW_MOD EXPRESSION
             | MINUS EXPRESSION %prec UNIT_MINUS
             | RW_NOT EXPRESSION %prec RW_NOT
             | EXPRESSION EQUALS EXPRESSION
             | EXPRESSION LESS EXPRESSION
             | EXPRESSION GREATER EXPRESSION
             | EXPRESSION LESSEQUAL EXPRESSION
             | EXPRESSION GREATEREQUAL EXPRESSION
             | EXPRESSION LTGT EXPRESSION
             | EXPRESSION RW_AND EXPRESSION %prec RW_AND
             | EXPRESSION RW_OR EXPRESSION %prec RW_OR
             | EXPRESSION RW_AND_THEN EXPRESSION %prec RW_AND_THEN
             | EXPRESSION RW_OR_ELSE EXPRESSION %prec RW_OR_ELSE
             | CALL_TO_METHOD
             | OPENPAR EXPRESSION:a CLOSEPAR {: RESULT = a; :}
             ;

